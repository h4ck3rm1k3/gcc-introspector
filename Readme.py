"""
GCC node type micro service


source http://www.gnu-pascal.de/gpc/Tree-nodes.html
"""
import sys
import types

# app specific
import cpp

class PythonClassGen(object):

    def transform_class_name(self, name):
        return ''.join([n.title() for n in name.split("_")])

    def create_python_class(self):
        class_name = self.class_name()
        base_classes = self.base_classes()
        object_data = self.object_data()
        klass = type(class_name, base_classes,object_data)
        #klass.__name__ = self.class_name()
        klass.__module__ = self.module_name()
        klass.__doc__ = self.class_doc()

        if klass.__module__ not in sys.modules:
            # create the module if needed
            module = types.ModuleType(klass.__module__, "dynamically created module")
            sys.modules[klass.__module__] = module

        # now register the class in the module
        module = sys.modules[klass.__module__]
        setattr(module, klass.__name__, klass)

        return klass

class NodeBase :
    pass

class DefNodeClass(PythonClassGen):
    def __init__(self, node_class):
        self.node_class=node_class

    def class_name(self):
        return self.transform_class_name(self.node_class)

    def class_doc(self):
        return """Autogenerated node_class based on usage in tree.def
        with the following parameters :
            node_class : {node_class}
        """.format(**self.__dict__)

    @staticmethod
    def module_name():
        return "gcc_node_base_class"

    def base_classes(self):
        return (NodeBase,)

    def object_data(self):
        # todo: maybe we done want to  put this meta data into the object itself,
        # maybe put it into the type object, or make it static

        return {
            'node_class' : self.node_class
        }


class DefTreeCode(PythonClassGen):
    def __init__(self, macro_name, struct_name, node_class, argc):
        self.macro_name=macro_name
        self.struct_name=struct_name
        self.node_class=node_class
        self.argc=argc

    def class_name(self):
        return self.transform_class_name(self.macro_name)

    def node_class_name(self):
        return self.transform_class_name(self.node_class)


    def class_doc(self):
        return """Autogenerated class based on tree.def
        with the following parameters :
            macro_name : {macro_name}
            struct_name : {struct_name}
            node_class : {node_class}
            argc : {argc}
        """.format(**self.__dict__)

    @staticmethod
    def module_name():
        return "gcc_node_types"

    def base_classes(self):
        module_name = DefNodeClass.module_name()
        module = sys.modules[module_name]
        klass = getattr(module, self.node_class_name())
        return (klass,)

    def object_data(self):
        # todo: maybe we done want to  put this meta data into the object itself,
        # maybe put it into the type object, or make it static
        return {
            'node_class' : self.node_class,
            'macro_name' : self.macro_name,
            'struct_name' : self.struct_name,
            'argc' : self.argc
        }

class TreeDefSourceFile(object):

    filename= '../gcc/gcc/tree.def'
    
    def __init__(self):
        self._codes = cpp.tree_codes(self.filename)
        self._node_classes = {}
        self._init_node_classes()

    def _init_node_classes(self):
        for obj in self._codes:
            name = obj[2] 
            if name not in self._node_classes:               
                self._node_classes[name]=DefNodeClass(name)

    def node_classes(self):
        return  self._node_classes.values()        

    def tree_codes(self):
        for obj in self._codes:
            yield DefTreeCode(obj[0],
                              obj[1],
                              obj[2],
                              obj[3])
        
